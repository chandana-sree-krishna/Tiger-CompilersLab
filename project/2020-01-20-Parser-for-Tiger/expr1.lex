(* Internal datatypes and functions required by the lexer *)
(* Keeping track of position in source                    *)

type lineNo            = int
type pos               = lineNo  (* The type of Should match with expr.yacc *)
val  lineRef : pos ref = ref 0   (* reference variable to keep track of position.
				    Typing not necessary just for clarity *)

fun updateLine n      = lineRef := !(lineRef) + n

(* Stuff done to make use of the Tokens module generated by expr.grm *)

type svalue        = Tokens.svalue
type ('a,'b) token = ('a,'b) Tokens.token
type lexresult     = (svalue,pos) token


fun lineRange l r = "line " ^ l
				  (*else ("line " ^ Int.toString l ^ "-" ^ Int.toString r)*)
fun error (e,l,r) = TextIO.output(TextIO.stdErr, lineRange l r ^ ":" ^ e ^ "\n")

fun eof   ()      = Tokens.EOF (!lineRef,!lineRef)

(* Some helper functions during lexing *)

fun charsToInt m (x :: xs) = charsToInt (10 * m + ord x - ord #"0") xs
  | charsToInt m []        = m

fun toSigned (#"-" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"~" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"+" :: xs) =   charsToInt 0 xs
  | toSigned xs           =   charsToInt 0 xs

val toInt        = toSigned o String.explode

val newlineCount = List.length o List.filter (fn x => x = #"\n") o String.explode

%%

%header (functor ExprLexFun(structure Tokens : Expr_TOKENS));
ws    = [\ \t \n];
digit = [0-9]+;
alpha = [a-zA-Z]+;
id = [A-Za-z][A-Za-z0-9]*;


%%

"#".*\n       => ( updateLine 1; lex ());
{ws}+         => ( lex() );

{digit}+    => ( Tokens.CONST (toInt yytext, !lineRef, !lineRef) );
{id}+ 			=> (Tokens.ID (yytext, !lineRef,!lineRef));
"+"         => ( Tokens.PLUS  (!lineRef,!lineRef) );
"-"         => ( Tokens.MINUS  (!lineRef,!lineRef) );
"*"         => ( Tokens.MUL (!lineRef,!lineRef) );
"/"			 		=> ( Tokens.DIV (!lineRef,!lineRef) );
"&"					=> (Tokens.AND(!lineRef,!lineRef));
"|"     		=> (Tokens.OR(!lineRef,!lineRef));
"="     		=> (Tokens.EQ(!lineRef,!lineRef));
">="				=> (Tokens.GE(!lineRef,!lineRef));
">"					=> (Tokens.GT(!lineRef,!lineRef));
"<="				=> (Tokens.LE(!lineRef,!lineRef));
"<"					=> (Tokens.LT(!lineRef,!lineRef));
"<>"				=> (Tokens.NEQ(!lineRef,!lineRef));
"."					=> (Tokens.DOT(!lineRef,!lineRef));
":"     		=> (Tokens.COLON(!lineRef,!lineRef));
";"     		=> (Tokens.SEMICOLON(!lineRef,!lineRef));
":="				=> (Tokens.ASSIGN(!lineRef,!lineRef));
"{"     		=> (Tokens.LFB(!lineRef,!lineRef));
"}"     		=> (Tokens.RFB(!lineRef,!lineRef));
"("     		=> (Tokens.LP(!lineRef,!lineRef));
")"     		=> (Tokens.RP(!lineRef,!lineRef));
"["     		=> (Tokens.LSB(!lineRef,!lineRef));
"]"     		=> (Tokens.RSB(!lineRef,!lineRef));
if  				=> (Tokens.IF(!lineRef,!lineRef));
then  			=> (Tokens.THEN(!lineRef,!lineRef));
else 				=> (Tokens.ELSE(!lineRef,!lineRef));
while				=> (Tokens.WHILE(!lineRef,!lineRef));
do  				=> (Tokens.DO(!lineRef,!lineRef));
for					=> (Tokens.FOR(!lineRef,!lineRef));
to 					=> (Tokens.TO(!lineRef,!lineRef));
do					=> (Tokens.DO(!lineRef,!lineRef));
break    		=> (Tokens.BREAK(!lineRef,!lineRef));
let					=> (Tokens.LET(!lineRef,!lineRef));
in					=> (Tokens.IN(!lineRef,!lineRef));
end 				=> (Tokens.END(!lineRef,!lineRef));
{alpha}+		=> (Tokens.STRING(yytext,!lineRef,!lineRef));

